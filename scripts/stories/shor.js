shorTitle=`Polynomial-Time Algorithms for Prime Factorizationand Discrete Logarithms on a Quantum Computer`
shorAuthor=`Peter W. Shor`
shorCopyright=`
AT&T Research, Room 2D-149, 600 Mountain Ave., Murray Hill,NJ 07974. 
A preliminary version of this paper appeared in the Proceedings of the 35th Annual Symposiumon Foundations of Computer Science, Santa Fe, NM, Nov. 20–22, 1994, IEEE Computer Society Press,pp. 124–134.`
shorText=`. One of the first results in the mathematics of computation, which underlies the subse- quent development of much of theoretical computer science, was the distinction between computable and non-computable functions shown in papers of Church [1936], Turing [1936], and Post [1936]. Central to this result is Church’s thesis, which says that all computing devices can be simulated by a Turing machine. This thesis greatly simpli- fies the study of computation, since it reduces the potential field of study from any of an infinite number of potential computing devices to Turing machines. Church’s thesis is not a mathematical theorem; to make it one would require a precise mathematical description of a computing device. Such a description, however, would leave open the possibility of some practical computing device which did not satisfy this precise math- ematical description, and thus would make the resulting mathematical theorem weaker than Church’s original thesis.
With the development of practical computers, it has become apparent that the dis- tinction between computable and non-computable functions is much too coarse; com- puter scientists are now interested in the exact efficiency with which specific functions can be computed. This exact efficiency, on the other hand, is too precise a quantity to work with easily. The generally accepted compromise between coarseness and precision distinguishes efficiently and inefficiently computable functions by whether the length of the computation scales polynomially or superpolynomially with the input size. The class of problems which can be solved by algorithms having a number of steps polynomial in the input size is known as P.
For this classification to make sense, we need it to be machine-independent. That is, we need to know that whether a function is computable in polynomial time is indepen- dent of the kind of computing device used. This corresponds to the following quantitative version of Church’s thesis, which Vergis et al. [1986] have called the “Strong Church’s Thesis” and which makes up half of the “Invariance Thesis” of van Emde Boas [1990].
Thesis (Quantitative Church’s thesis). Any physical computing device can be simu- lated by a Turing machine in a number of steps polynomial in the resources used by the computing device.
In statements of this thesis, the Turing machine is sometimes augmented with a ran- dom number generator, as it has not yet been determined whether there are pseudoran- dom number generators which can efficiently simulate truly random number generators for all purposes. Readers who are not comfortable with Turing machines may think instead of digital computers having an amount of memory that grows linearly with the length of the computation, as these two classes of computing machines can efficiently simulate each other.
There are two escape clauses in the above thesis. One of these is the word “physical.” Researchers have produced machine models that violate the above quantitative Church’s thesis, but most of these have been ruled out by some reason for why they are not “phys- ical,” that is, why they could not be built and made to work. The other escape clause in the above thesis is the word “resources,” the meaning of which is not completely speci- fied above. There are generally two resources which limit the ability of digital computers to solve large problems: time (computation steps) and space (memory). There are more resources pertinent to analog computation; some proposed analog machines that seem able to solve NP-complete problems in polynomial time have required the machining of exponentially precise parts, or an exponential amount of energy. (See Vergis et al. [1986] and Steiglitz [1988]; this issue is also implicit in the papers of Canny and Reif [1987] and Choi et al. [1995] on three-dimensional shortest paths.)
For quantum computation, in addition to space and time, there is also a third poten- tially important resource, precision. For a quantum computer to work, at least in any currently envisioned implementation, it must be able to make changes in the quantum states of objects (e.g., atoms, photons, or nuclear spins). These changes can clearly not be perfectly accurate, but must contain some small amount of inherent impreci- sion. If this imprecision is constant (i.e., it does not depend on the size of the input), then it is not known how to compute any functions in polynomial time on a quantum computer that cannot also be computed in polynomial time on a classical computer with a random number generator. However, if we let the precision grow polynomially in the input size (that is, we let the number of bits of precision grow logarithmically in the input size), we appear to obtain a more powerful type of computer. Allowing the same polynomial growth in precision does not appear to confer extra computing power to classical mechanics, although allowing exponential growth in precision does [Hartmanis and Simon 1974, Vergis et al. 1986].
As far as we know, what precision is possible in quantum state manipulation is dic- tated not by fundamental physical laws but by the properties of the materials and the architecture with which a quantum computer is built. It is currently not clear which architectures, if any, will give high precision, and what this precision will be. If the pre- cision of a quantum computer is large enough to make it more powerful than a classical computer, then in order to understand its potential it is important to think of precision as a resource that can vary. Treating the precision as a large constant (even though it is almost certain to be constant for any given machine) would be comparable to treating a classical digital computer as a finite automaton — since any given computer has a fixed amount of memory, this view is technically correct; however, it is not particularly useful.
Because of the remarkable effectiveness of our mathematical models of computation, computer scientists have tended to forget that computation is dependent on the laws of physics. This can be seen in the statement of the quantitative Church’s thesis in van Emde Boas [1990], where the word “physical” in the above phrasing is replaced with the word “reasonable.” It is difficult to imagine any definition of “reasonable” in this context which does not mean “physically realizable,” i.e., that this computing machine could actually be built and would work.
Computer scientists have become convinced of the truth of the quantitative Church’s thesis through the failure of all proposed counter-examples. Most of these proposed counter-examples have been based on the laws of classical mechanics; however, the uni- verse is in reality quantum mechanical. Quantum mechanical objects often behave quite differently from how our intuition, based on classical mechanics, tells us they should. It thus seems plausible that the natural computing power of classical mechanics corre- sponds to Turing machines,1 while the natural computing power of quantum mechanics might be greater. The first person to look at the interaction between computation and quantum me- chanics appears to have been Benioff [1980, 1982a, 1982b]. Although he did not ask whether quantum mechanics conferred extra power to computation, he showed that re- versible unitary evolution was sufficient to realize the computational power of a Turing machine, thus showing that quantum mechanics is at least as powerful computationally as a classical computer. This work was fundamental in making later investigation of quantum computers possible.
Feynman [1982,1986] seems to have been the first to suggest that quantum mechanics might be more powerful computationally than a Turing machine. He gave arguments as to why quantum mechanics might be intrinsically expensive computationally to simulate on a classical computer. He also raised the possibility of using a computer based on quantum mechanical principles to avoid this problem, thus implicitly asking the converse question: by using quantum mechanics in a computer can you compute more efficiently than on a classical computer? Deutsch [1985, 1989] was the first to ask this question explicitly. In order to study this question, he defined both quantum Turing machines and quantum circuits and investigated some of their properties.
The question of whether using quantum mechanics in a computer allows one to obtain more computational power was more recently addressed by Deutsch and Jozsa [1992] and Berthiaume and Brassard [1992a, 1992b]. These papers showed that there are problems which quantum computers can quickly solve exactly, but that classical computers can only solve quickly with high probability and the aid of a random number generator. However, these papers did not show how to solve any problem in quantum polynomial time that was not already known to be solvable in polynomial time with the aid of a random number generator, allowing a small probability of error; this is the characterization of the complexity class BPP, which is widely viewed as the class of efficiently solvable problems.
Further work on this problem was stimulated by Bernstein and Vazirani [1993]. One of the results contained in their paper was an oracle problem (that is, a problem involving a “black box” subroutine that the computer is allowed to perform, but for which no code is accessible) which can be done in polynomial time on a quantum Turing machine but which requires super-polynomial time on a classical computer. This result was improved by Simon [1994], who gave a much simpler construction of an oracle problem which takes polynomial time on a quantum computer but requires exponential time on a classical computer. Indeed, while Bernstein and Vaziarni’s problem appears contrived, Simon’s problem looks quite natural. Simon’s algorithm inspired the work presented in this paper.
Two number theory problems which have been studied extensively but for which no polynomial-time algorithms have yet been discovered are finding discrete logarithms and factoring integers [Pomerance 1987, Gordon 1993, Lenstra and Lenstra 1993, Adleman and McCurley 1995]. These problems are so widely believed to be hard that several cryptosystems based on their difficulty have been proposed, including the widely used RSA public key cryptosystem developed by Rivest, Shamir, and Adleman [1978]. We show that these problems can be solved in polynomial time on a quantum computer with a small probability of error.
Currently, nobody knows how to build a quantum computer, although it seems as though it might be possible within the laws of quantum mechanics. Some suggestions1994, Cirac and Zoller 1995, DiVincenzo 1995, Sleator and Weinfurter 1995, Barenco et al. 1995b, Chuang and Yamomoto 1995], but there will be substantial difficulty in build- ing any of these [Landauer 1995a, Landauer 1995b, Unruh 1995, Chuang et al. 1995, Palma et al. 1995]. The most difficult obstacles appear to involve the decoherence of quantum superpositions through the interaction of the computer with the environment, and the implementation of quantum state transformations with enough precision to give accurate results after many computation steps. Both of these obstacles become more difficult as the size of the computer grows, so it may turn out to be possible to build small quantum computers, while scaling up to machines large enough to do interesting computations may present fundamental difficulties.
Even if no useful quantum computer is ever built, this research does illuminate the problem of simulating quantum mechanics on a classical computer. Any method of doing this for an arbitrary Hamiltonian would necessarily be able to simulate a quantum computer. Thus, any general method for simulating quantum mechanics with at most a polynomial slowdown would lead to a polynomial-time algorithm for factoring.
The rest of this paper is organized as follows. In §2, we introduce the model of quantum computation, the quantum gate array, that we use in the rest of the paper. In §§3 and 4, we explain two subroutines that are used in our algorithms: reversible modular exponentiation in §3 and quantum Fourier transforms in §4. In §5, we give our algorithm for prime factorization, and in §6, we give our algorithm for extracting discrete logarithms. In §7, we give a brief discussion of the practicality of quantum computation and suggest possible directions for further work. In this section we give a brief introduction to quantum computation, emphasizing the properties that we will use. We will describe only quantum gate arrays, or quantum acyclic circuits, which are analogous to acyclic circuits in classical computer science. For other models of quantum computers, see references on quantum Turing machines [Deutsch 1989, Bernstein and Vazirani 1993, Yao 1993] and quantum cellular automata [Feynman 1986, Margolus 1986, 1990, Lloyd 1993, Biafore 1994]. If they are allowed a small probability of error, quantum Turing machines and quantum gate arrays can compute the same functions in polynomial time [Yao 1993]. This may also be true for the various models of quantum cellular automata, but it has not yet been proved. This gives evidence that the class of functions computable in quantum polynomial time with a small probability of error is robust, in that it does not depend on the exact architecture of a quantum computer. By analogy with the classical class BPP, this class is called BQP.
Consider a system with n components, each of which can have two states. Whereas in classical physics, a complete description of the state of this system requires only n bits, in quantum physics, a complete description of the state of this system requires 2n − 1 complex numbers. To be more precise, the state of the quantum system is a point in a 2n-dimensional vector space. For each of the 2n possible classical positions of the components, there is a basis state of this vector space which we represent, for example, by |011···0⟩ meaning that the first bit is 0, the second bit is 1, and so on. Here, the ket notation |x⟩ means that x is a (pure) quantum state. (Mixed states will not be discussed in this paper, and thus we do not define them; see a quantum theory book such as Peres [1993] for this definition.) The Hilbert space associated with this quantum system is the complex vector space with these 2n states as basis vectors, and the state of the system at any time is represented by a unit-length vector in this Hilbert space. As multiplying this state vector by a unit-length complex phase does not change any behavior of the state, we need only 2n − 1 complex numbers to completely describe the state. We represent this superposition of states as (2.1). where the amplitudes ai are complex numbers such that  i |ai|2 = 1 and each |Si⟩ is a basis vector of the Hilbert space. If the machine is measured (with respect to this basis) at any particular step, the probability of seeing basis state |Si⟩ is |ai|2; however, measuring the state of the machine projects this state to the observed basis vector |Si⟩. Thus, looking at the machine during the computation will invalidate the rest of the computation. In this paper, we only consider measurements with respect to the canonical basis. This does not greatly restrict our model of computation, since measurements in other reasonable bases could be simulated by first using quantum computation to perform a change of basis and then performing a measurement in the canonical basis.
In order to use a physical system for computation, we must be able to change the state of the system. The laws of quantum mechanics permit only unitary transforma- tions of state vectors. A unitary matrix is one whose conjugate transpose is equal to its inverse, and requiring state transformations to be represented by unitary matrices ensures that summing the probabilities of obtaining every possible outcome will result in 1. The definition of quantum circuits (and quantum Turing machines) only allows local unitary transformations; that is, unitary transformations on a fixed number of bits. This is physically justified because, given a general unitary transformation on n bits, it is not at all clear how one would efficiently implement it physically, whereas two-bit transformations can at least in theory be implemented by relatively simple physical systems [Cirac and Zoller 1995, DiVincenzo 1995, Sleator and Weinfurter 1995, Chuang and Yamomoto 1995]. While general n-bit transformations can always be built out of two-bit transformations [DiVincenzo 1995, Sleator and Weinfurter 1995, Lloyd 1995, Deutsch et al. 1995], the number required will often be exponential in n [Barenco et al. 1995a]. Thus, the set of two-bit transformations form a set of building blocks for quantum circuits in a manner analogous to the way a universal set of classical gates (such as the AND, OR and NOT gates) form a set of building blocks for classical circuits. In fact, for a universal set of quantum gates, it is sufficient to take all one-bit gates and a single type of two-bit gate, the controlled NOT, which negates the second bit if and only if the first bit is 1.
Perhaps an example will be informative at this point. A quantum gate can be expressed as a truth table: for each input basis vector we need to give the output of the gate. One such gate is: (2.2). Not all truth tables correspond to physically feasible quantum gates, as many truth tables will not give rise to unitary transformations.
The same gate can also be represented as a matrix. The rows correspond to input basis vectors. The columns correspond to output basis vectors. The (i,j) entry gives, when the ith basis vector is input to the gate, the coefficient of the jth basis vector in the corresponding output of the gate. The truth table above would then correspond to the following matrix: (2.3). A quantum gate is feasible if and only if the corresponding matrix is unitary, i.e., its inverse is its conjugate transpose.
Suppose our machine is in the superposition of states(2.4). and we apply the unitary transformation represented by (2.2) and (2.3) to this state. The resulting output will be the result of multiplying the vector (2.4) by the matrix (2.3). The machine will thus go to the superposition of states (2.5). This example shows the potential effects of interference on quantum computation. Had we started with either the state |10⟩ or the state |11⟩, there would have been a chance of observing the state |10⟩ after the application of the gate (2.3). However, when we start with a superposition of these two states, the probability amplitudes for the state |10⟩ cancel, and we have no possibility of observing |10⟩ after the application of the gate. Notice that the output of the gate would have been |10⟩ instead of |11⟩ had we started with the superposition of states (2.6). which has the same probabilities of being in any particular configuration if it is observed as does the superposition (2.4). If we apply a gate to only two bits of a longer basis vector (now our circuit must have more than two wires), we multiply the gate matrix by the two bits to which the gate is applied, and leave the other bits alone. This corresponds to multiplying the whole state by the tensor product of the gate matrix on those two bits with the identity matrix on the remaining bits.
A quantum gate array is a set of quantum gates with logical “wires” connecting their inputs and outputs. The input to the gate array, possibly along with extra work bits that are initially set to 0, is fed through a sequence of quantum gates. The values of the bits are observed after the last quantum gate, and these values are the output. To compare gate arrays with quantum Turing machines, we need to add conditions that make gate arrays a uniform complexity class. In other words, because there is a different gate array for each size of input, we need to keep the designer of the gate arrays from hiding non-computable (or hard to compute) information in the arrangement of the gates. To make quantum gate arrays uniform, we must add two things to the definition of gate arrays. The first is the standard requirement that the design of the gate array be produced by a polynomial-time (classical) computation. The second requirement should be a standard part of the definition of analog complexity classes, although since analog complexity classes have not been widely studied, this requirement is much less widely known. This requirement is that the entries in the unitary matrices describing the gates must be computable numbers. Specifically, the first log n bits of each entry should be classically computable in time polynomial in n [Solovay 1995]. This keeps non-computable (or hard to compute) information from being hidden in the bits of the amplitudes of the quantum gates. 3 Reversible logic and modular exponentiation. The definition of quantum gate arrays gives rise to completely reversible computation. That is, knowing the quantum state on the wires leading out of a gate tells uniquely what the quantum state must have been on the wires leading into that gate. This is a reflection of the fact that, despite the macroscopic arrow of time, the laws of physics ap- pear to be completely reversible. This would seem to imply that anything built with the laws of physics must be completely reversible; however, classical computers get around this fact by dissipating energy and thus making their computations thermodynamically irreversible. This appears impossible to do for quantum computers because superpo- sitions of quantum states need to be maintained throughout the computation. Thus, quantum computers necessarily have to use reversible computation. This imposes ex- tra costs when doing classical computations on a quantum computer, as is sometimes necessary in subroutines of quantum computations.
Because of the reversibility of quantum computation, a deterministic computation is performable on a quantum computer only if it is reversible. Luckily, it has already been shown that any deterministic computation can be made reversible [Lecerf 1963, Bennett 1973]. In fact, reversible classical gate arrays have been studied. Much like the result that any classical computation can be done using NAND gates, there are also universal gates for reversible computation. Two of these are Toffoli gates [Toffoli 1980] and Fredkin gates [Fredkin and Toffoli 1982]; these are illustrated in Table 3.1.
The Toffoli gate is just a controlled controlled NOT, i.e., the last bit is negated if and only if the first two bits are 1. In a Toffoli gate, if the third input bit is set to 1, then the third output bit is the NAND of the first two input bits. Since NAND is auniversal gate for classical gate arrays, this shows that the Toffoli gate is universal. In a Fredkin gate, the last two bits are swapped if the first bit is 0, and left untouched if the first bit is 1. For a Fredkin gate, if the third input bit is set to 0, the second output bit is the AND of the first two input bits; and if the last two input bits are set to 0 and 1 respectively, the second output bit is the NOT of the first input bit. Thus, both AND and NOT gates are realizable using Fredkin gates, showing that the Fredkin gate is universal.
From results on reversible computation [Lecerf 1963, Bennett 1973], we can compute any polynomial time function F (x) as long as we keep the input x in the computer. We do this by adapting the method for computing the function F non-reversibly. These results can easily be extended to work for gate arrays [Toffoli 1980, Fredkin and Toffoli 1982]. When AND, OR or NOT gates are changed to Fredkin or Toffoli gates, one obtains both additional input bits, which must be preset to specified values, and additional output bits, which contain the information needed to reverse the computation. While the additional input bits do not present difficulties in designing quantum computers, the additional output bits do, because unless they are all reset to 0, they will affect the interference patterns in quantum computation. Bennett’s method for resetting these bits to 0 is shown in the top half of Table 3.2. A non-reversible gate array may thus be turned into a reversible gate array as follows. First, duplicate the input bits as many times as necessary (since each input bit could be used more than once by the gate array). Next, keeping one copy of the input around, use Toffoli and Fredkin gates to simulate non- reversible gates, putting the extra output bits into the RECORD register. These extra output bits preserve enough of a record of the operations to enable the computation of the gate array to be reversed. Once the output F (x) has been computed, copy it into a register that has been preset to zero, and then undo the computation to erase both the first OUTPUT register and the RECORD register.
To erase x and replace it with F (x), in addition to a polynomial-time algorithm for F , we also need a polynomial-time algorithm for computing x from F (x); i.e., we need that F is one-to-one and that both F and F −1 are polynomial-time computable. The method for this computation is given in the whole of Table 3.2. There are two stages to this computation. The first is the same as before, taking x to (x,F(x)). For the second stage, shown in the bottom half of Table 3.2, note that if we have a method to compute F −1 non-reversibly in polynomial time, we can use the same technique to reversibly map F (x) to (F (x), F −1 (F (x))) = (F (x), x). However, since this is a reversible computation, we can reverse it to go from (x, F (x)) to F (x). Put together, these two pieces take x to F (x).
The above discussion shows that computations can be made reversible for only a constant factor cost in time, but the above method uses as much space as it does time. If the classical computation requires much less space than time, then making it reversible in this manner will result in a large increase in the space required. There are methods that do not use as much space, but use more time, to make computations reversible [Bennett 1989, Levine and Sherman 1990]. While there is no general method that does not cause an increase in either space or time, specific algorithms can sometimes be made reversible without paying a large penalty in either space or time; at the end of this section we will show how to do this for modular exponentiation, which is a subroutine necessary for quantum factoring.
The bottleneck in the quantum factoring algorithm; i.e., the piece of the fac- toring algorithm that consumes the most time and space, is modular exponentia- tion. The modular exponentiation problem is, given n, x, and r, find xr (mod n). The best classical method for doing this is to repeatedly square of x (mod n) to get x2i (mod n) for i ≤ log2 r, and then multiply a subset of these powers (mod n) to get xr (mod n). If we are working with l-bit numbers, this requires O(l) squar- ings and multiplications of l-bit numbers (mod n). Asymptotically, the best clas- sical result for gate arrays for multiplication is the Scho ̈nhage–Strassen algorithm [Scho ̈nhage and Strassen 1971, Knuth 1981, Scho ̈nhage 1982]. This gives a gate array for integer multiplication that uses O(l log l log log l) gates to multiply two l-bit numbers. Thus, asymptotically, modular exponentiation requires O(l2 log l log log l) time. Making this reversible would na ̈ıvely cost the same amount in space; however, one can reuse the space used in the repeated squaring part of the algorithm, and thus reduce the amount of space needed to essentially that required for multiplying two l-bit numbers; one simple method for reducing this space (although not the most versatile one) will be given later in this section. Thus, modular exponentiation can be done in O(l2 log l log log l) time and O(l log l log log l) space.
While the Scho ̈nhage–Strassen algorithm is the best multiplication algorithm discov- ered to date for large l, it does not scale well for small l. For small numbers, the best gate arrays for multiplication essentially use elementary-school longhand multiplication in binary. This method requires O(l2) time to multiply two l-bit numbers, and thus modular exponentiation requires O(l3) time with this method. These gate arrays can be made reversible, however, using only O(l) space.
We will now give the method for constructing a reversible gate array that takes onlyO(l) space and O(l3) time to compute (a,xa (mod n)) from a, where a, x, and n are l-bit numbers. The basic building block used is a gate array that takes b as input and outputs b + c (mod n). Note that here b is the gate array’s input but c and n are built into the structure of the gate array. Since addition (mod n) is computable in O(log n) time classically, this reversible gate array can be made with only O(log n) gates and O(log n) work bits using the techniques explained earlier in this section.
The technique we use for computing xa (mod n) is essentially the same as the classi- cal method. First, by repeated squaring we compute x2i (mod n) for all i < l. Then, to obtain xa (mod n) we multiply the powers x2i (mod n) where 2i appears in the binary expansion of a. In our algorithm for factoring n, we only need to compute xa (mod n) where a is in a superposition of states, but x is some fixed integer. This makes things much easier, because we can use a reversible gate array where a is treated as input, but where x and n are built into the structure of the gate array. Thus, we can use the algorithm described by the following pseudocode; here, ai represents the ith bit of a in binary, where the bits are indexed from right to left and the rightmost bit of a is a0. <Algorithm>. The variable a is left unchanged by the code and xa (mod n) is output as the variable power . Thus, this code takes the pair of values (a, 1) to (a, xa (mod n)).
This pseudocode can easily be turned into a gate array; the only hard part of this is the fourth line, where we multiply the variable power by x2i (mod n); to do this we need to use a fairly complicated gate array as a subroutine. Recall that x2i (mod n) can be computed classically and then built into the structure of the gate array. Thus, to implement this line, we need a reversible gate array that takes b as input and gives bc (mod n) as output, where the structure of the gate array can depend on c and n. Of course, this step can only be reversible if gcd(c,n) = 1, i.e., if c and n have no common factors, as otherwise two distinct values of b will be mapped to the same value of bc (mod n); this case is fortunately all we need for the factoring algorithm. We will show how to build this gate array in two stages. The first stage is directly analogous to exponentiation by repeated multiplication; we obtain multiplication from repeated addition (mod n). Pseudocode for this stage is as follows. <Pseudo code>. Again, 2^i c (mod n) can be precomputed and built into the structure of the gate array. The above pseudocode takes b as input, and gives (b, bc (mod n)) as output. To get the desired result, we now need to erase b. Recall that gcd(c, n) = 1, so there is a c−1 (mod n) with c c−1 ≡ 1 (mod n). Multiplication by this c−1 could be used to reversibly take bc (mod n) to (bc (mod n), bcc−1 (mod n)) = (bc (mod n), b). This is just the reverse of the operation we want, and since we are working with reversible computing, we can turn this operation around to erase b. The pseudocode for this follows. <Pseudo code>. As before, resulti is the ith bit of result.
Note that at this stage of the computation, b should be 0. However, we did not set b
directly to zero, as this would not have been a reversible operation and thus impossible on a quantum computer, but instead we did a relatively complicated sequence of operations which ended with b = 0 and which in fact depended on multiplication being a group (mod n). At this point, then, we could do something somewhat sneaky: we could measure b to see if it actually is 0. If it is not, we know that there has been an error somewhere in the quantum computation, i.e., that the results are worthless and we should stop the computer and start over again. However, if we do find that b is 0, then we know (because we just observed it) that it is now exactly 0. This measurement thus may bring the quantum computation back on track in that any amplitude that b had for being non-zero has been eliminated. Further, because the probability that we observe a state is proportional to the square of the amplitude of that state, depending on the error model, doing the modular exponentiation and measuring b every time that we know that it should be 0 may have a higher probability of overall success than the same computation done without the repeated measurements of b; this is the quantum watchdog (or quantum Zeno) effect [Peres 1993]. The argument above does not actually show that repeated measurement of b is indeed beneficial, because there is a cost (in time, if nothing else) of measuring b. Before this is implemented, then, it should be checked with analysis or experiment that the benefit of such measurements exceeds their cost. However, I believe that partial measurements such as this one are a promising way of trying to stabilize quantum computations.
Currently, Scho ̈nhage–Strassen is the algorithm of choice for multiplying very large numbers, and longhand multiplication is the algorithm of choice for small numbers. There are also multiplication algorithms which have efficiencies between these two al- gorithms, and which are the best algorithms to use for intermediate length numbers [Karatsuba and Ofman 1962, Knuth 1981, Scho ̈nhage et al. 1994]. It is not clear which algorithms are best for which size numbers. While this may be known to some extent for classical computation [Scho ̈nhage et al. 1994], using data on which algorithms work better on classical computers could be misleading for two reasons: First, classical com- puters need not be reversible, and the cost of making an algorithm reversible depends on the algorithm. Second, existing computers generally have multiplication for 32- or 64-bit numbers built into their hardware, and this will increase the optimal changeover points to asymptotically faster algorithms; further, some multiplication algorithms can take better advantage of this hardwired multiplication than others. Thus, in order to program quantum computers most efficiently, work needs to be done on the best way of implementing elementary arithmetic operations on quantum computers. One tantalizing fact is that the Scho ̈nhage–Strassen fast multiplication algorithm uses the fast Fourier transform, which is also the basis for all the fast algorithms on quantum computers discovered to date; it is tempting to speculate that integer multiplication itself might be speeded up by a quantum algorithm; if possible, this would result in a somewhat faster asymptotic bound for factoring on a quantum computer, and indeed could even make breaking RSA on a quantum computer asymptotically faster than encrypting with RSA on a classical computer.`